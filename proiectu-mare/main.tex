\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[english]{babel}
\usepackage{float}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{xcolor}

\title{\textbf{QASST Project}}
\author{
Stan Ioan-Victor, ioan.victor.stan@ubbcluj.ro\\
Sebastian-George Hojda, sebastian.hojda@ubbcluj.ro\\
Timotei Copaciu, timotei.copaciu@ubbcluj.ro
}

\newpage

\begin{document}
\maketitle


\tableofcontents

\newpage

\section{Software Tested}
\label{label:Software_tested}

\href{https://github.com/Commando-X/vuln-bank}{Vuln-Bank} \cite{ref:vulnBankRepo} is the application we're testing today. I know you might be tired of all the intentionally vulnerable apps, but it'll be very unlikely for us to stay and try to find issues in actual apps we use, because we're still learning, so what can we do \dots

Vuln-Bank is just one of the few ones where the issues that you can exploit.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/vuln_dashboard.png}
    \caption{VulnBank Application Dashboard (Authenticated User View)}
    \label{fig:dashboard}
\end{figure}



\section{Approach on Security}
\label{label:Approach}

We're tackling both defensive and offensive, Timotei will be testing the application from a defensive perspective, and Victor with Sebi will be doing it offensively.

All 3 of us are developers, working in the industry, in the beginning of our careers.

The main objective of this bug-hunt was so that we can learn more about triaging, exploiting and defending against bugs.

The tools we've used were: 
\begin{itemize}
    \item Snyk (Defensave),
    \item Tenable's Nessus(Offensive),
    \item Burp Suite (Offensive)
\end{itemize}


\section{Strategy Applied}
\label{label:Strategy}

\subsection{Offensive approach}

\textcolor{blue}{
\textit{Using the offensive approach:}\\

Victor:\\

I've used the Tenable's tool: Nessus, via docker to find and exploit some of the vulerabilities, and got free access to Nessus Essentials Plus licence for students.


Started a discovery Scan for the hosted version of https://vulnbank.org.\\

\par For the offensive strategy, we adopted a \textbf{Black-box Penetration Testing} methodology, aligned with the \textit{OWASP Web Security Testing Guide (WSTG)}. This approach simulates a real-world external attacker who has no prior knowledge of the system's internal architecture or source code. Unlike the defensive team which had full visibility, our goal was to identify vulnerabilities strictly through external interaction.

Our strategy was structured in three main phases:
\begin{itemize}
    \item \textbf{Reconnaissance \& Discovery (Passive \& Active):} We started by exploring the application to map out the attack surface. This involved identifying all accessible endpoints, analyzing HTTP traffic using proxy tools, and looking for exposed information resources (such as API definitions) that shouldn't be public. We specifically looked for "low hanging fruit" that could facilitate further attacks.
    \item \textbf{Vulnerability Scanning \& Analysis:} Once the endpoints were identified (specifically the REST API), we analyzed the input vectors (URL parameters, headers, JSON bodies) to check for lack of sanitization. We employed automated scanners (Nessus) to establish a baseline, followed by manual verification to rule out false positives.
    \item \textbf{Exploitation:} Upon identifying potential weaknesses, we crafted specific payloads (manual exploitation) to confirm the vulnerabilities and demonstrate their impact. The focus was on demonstrating \textit{Proof of Concept (PoC)} for data exfiltration rather than destructive actions.
\end{itemize}

\subsection{Defensive approach}

\par The defensive strategy adopted for this project focuses on Static Application Security Testing (SAST) to identify vulnerabilities early in the development lifecycle. Our primary objective was to assess the code quality and conformance to security specifications without executing the application. To achieve this, we employed Snyk, a specialized SAST tool, to perform a comprehensive scan of the source code. This approach allows us to detect "code smells" and insecure coding patterns that might otherwise be missed during manual reviews.

\par The investigation specifically targeted the critical components of the application responsible for data handling and user authentication. We configured the scanning strategy to focus on the backend database interface files and the HTTP session management modules, as these are high-risk areas for data leaks. By isolating these aspects, we aimed to uncover structural weaknesses related to input validation and session security configuration.

\par Our analysis strategy involved filtering the automated report generated by the tool to prioritize actionable threats. We focused on identifying vulnerabilities with High and Medium severity levels that directly impact the confidentiality and integrity of user data. Specifically, we looked for patterns indicating SQL Injection flaws in the query structures and Improper Certificate Validation in the communication layer. Additionally, we investigated the frontend code for Cross-site Scripting (XSS) risks and inspected the cookie generation logic for missing security attributes.

\par Finally, the applied strategy includes a remediation verification phase. After identifying and manually reproducing the reported vulnerabilities to rule out false positives, we plan to implement the code fixes suggested by the Snyk scanner. This "scan-fix-rescan" cycle ensures that the security attributes are effectively restored and that the remediation steps do not introduce regression issues.

\section{Vulnerabilities}
\label{label:Vulnerabilities}

\par \textbf{Vulnerability 01: SQL Injection (CWE-89 \cite{vul01:sqlInjection} - Severity: High.}
\par This vulnerability was identified by the Snyk SAST tool with a high priority score of 839. The issue resides in the \texttt{app.py} file, within the \texttt{api\_v1\_forgot\_password} function. The scanner detected that the application processes the \texttt{/api/v1/forgot-password} POST request by taking the \texttt{username} input directly from the JSON body and embedding it into a database query.
\par The specific code flaw is the use of a Python f-string to construct the SQL command: \texttt{f"SELECT id FROM users WHERE username='\{username\}'"}. Because the input is not sanitized or parameterized before being passed to \texttt{execute\_query}, an attacker can inject malicious SQL syntax to manipulate the query logic. 

\par \textbf{Vulnerability 02: Improper Certificate Validation (CWE-295 \cite{vul02:certValidation}) - Severity: High.}
\par This vulnerability was flagged with a priority score of 802 and is located in the \texttt{app.py} file, inside the \texttt{upload\_profile\_picture\_url} function. The scanner identified a critical security misconfiguration in how the application handles external HTTP requests. Specifically, the code attempts to fetch an image from a user-supplied URL using the Python \texttt{requests} library: \texttt{requests.get(..., verify=False)}.
\par By explicitly setting the \texttt{verify} parameter to \texttt{False}, the application disables SSL/TLS certificate verification. This effectively allows the application to trust any certificate presented by the server, including self-signed or malicious ones. This vulnerability opens the door to Man-in-the-Middle (MitM) attacks, where an attacker could intercept the connection, inspect the traffic, or inject malicious data into the response stream.

\par \textbf{Vulnerability 03: DOM-based Cross-site Scripting (CWE-79 \cite{vul03:crossSite}) - Severity: Medium.}
\par Snyk flagged this vulnerability with a priority score of 602. The security flaw is located in the frontend template file \texttt{templates/forgot\_password.html}. The issue occurs within the JavaScript code responsible for handling the "Forgot Password" form submission. After receiving a JSON response from the API, the application dynamically updates the user interface using the command: \texttt{document.getElementById('message').innerHTML = data.message}.
\par The use of \texttt{innerHTML} allows the browser to parse the data as HTML elements rather than plain text. If the backend response—specifically the \texttt{data.message} field—contains malicious JavaScript (e.g., \texttt{<script>alert(1)</script>}), it will be executed immediately in the user's browser. This creates a DOM-based XSS vulnerability.

\par \textbf{Vulnerability 04: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute (CWE-614 \cite{vul04:sensCookie}) - Severity: Low.}
\par This vulnerability was identified by Snyk with a priority score of 402. The issue is located in the \texttt{app.py}, within the \texttt{login} function. Upon successful user authentication, the application generates a JWT session token and sets it in the user's browser using \texttt{response.set\_cookie('token', token, httponly=True)}.
\par While the developer correctly included the \texttt{httponly=True} flag to prevent client-side scripts from accessing the cookie, the \texttt{secure} flag was omitted. By default, this flag is set to \texttt{False}, meaning the sensitive session token can be transmitted over unencrypted HTTP connections. This configuration exposes the user's session to Man-in-the-Middle (MitM) attacks, where an attacker could intercept the plain-text cookie.

\par \textbf{Vulnerability 05: API Documentation Exposure (CWE-200 \cite{vule} - Severity: Medium)}
\par This vulnerability involves the exposure of sensitive API documentation to unauthorized users. We discovered that the Swagger/OpenAPI documentation interface was publicly accessible at the \texttt{/api/docs} endpoint without any authentication. This documentation provides a complete blueprint of the backend, including hidden endpoints, required parameters, and data models. Attackers can use this information to map the application's attack surface rapidly and craft targeted attacks against specific API routes (like the transaction history endpoint) without needing to guess or brute-force URLs.

\par \textbf{Vulnerability 06: SQL Injection in API Endpoints (CWE-89 \cite{vuld} - Severity: High)}
\par We identified a critical SQL Injection vulnerability in the \texttt{/api/transactions} endpoint. The application fails to properly sanitize user input supplied in the transaction filtering parameters before using it in a database query. By injecting malicious SQL syntax (e.g., \texttt{' OR '1'='1}), an attacker can manipulate the backend query logic. This allows the attacker to bypass access controls and retrieve the complete transaction history for all users in the database, violating data confidentiality and potentially integrity.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/api_documentation_transactions.png}
    \caption{The /transactions route that allows SQL Injections discovered using the Swagger API documentation}
    \label{fig:sqli_proof}
\end{figure}


Found by Nessus (names and descriptions provided by Nexus): \\

\textbf{Vulerability 07: Web Application Potentially Vulnerable to Clickjacking CVE-2025-64387.}

Description\\
The remote web server does not set an X-Frame-Options response header or a Content-Security-Policy 'frame-ancestors' response header in all content responses. This could potentially expose the site to a clickjacking or UI redress attack, in which an attacker can trick a user into clicking an area of the vulnerable page that is different than what the user perceives the page to be. This can result in a user performing fraudulent or malicious transactions.

\textbf{Vulerability 08: Web Server Transmits Cleartext Credentials CWE-319}

Description: \\
The remote web server contains several HTML form fields containing an input of type 'password' which transmit their information to a remote web server in cleartext.

An attacker eavesdropping the traffic between web browser and server may obtain logins and passwords of valid users.



\section{Aimed Assets}
\label{label:Assets}
The effect these vulnerabilites have on the assets is presented below.
\begin{table}[H]
\centering
\caption{Vulnerability Asset Mapping}
\label{tab:vulnerability_assets}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Vuln. number} & \textbf{vulnerability name} & \textbf{affected assets} \\ \hline
1 & SQL injection & \textbf{file:} \texttt{app.py} \newline \textbf{function:} \texttt{api\_v1\_forgot\_password} \newline \textbf{data:} User database (IDs, credentials) \\ \hline
2 & Improper certificate validation & \textbf{file:} \texttt{app.py} \newline \textbf{function:} \texttt{upload\_profile\_picture\_url} \newline \textbf{communication:} External HTTP requests (SSL/TLS) \\ \hline
3 & DOM-based Cross-site scripting & \textbf{file:} \texttt{templates/forgot\_password.html} \newline \textbf{component:} DOM element \texttt{'message'} \newline \textbf{data:} User browser session, frontend UI \\ \hline
4 & Sensitive cookie without 'secure' attribute & \textbf{file:} \texttt{app.py} \newline \textbf{function:} \texttt{login} \newline \textbf{token:} JWT session token (\texttt{'token'} cookie) \\ \hline
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Offensive Vulnerability Asset Mapping}
\label{tab:offensive_assets}
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Vuln. number} & \textbf{Vulnerability Name} & \textbf{Affected Assets} \\ \hline
5 & API Documentation Exposure & \textbf{Resource:} \texttt{/api/docs}, \texttt{openapi.json} \newline \textbf{Information:} Full API structure, hidden endpoints \\ \hline
6 & SQL Injection in API & \textbf{Endpoint:} \texttt{/api/transactions} \newline \textbf{Data:} User Transaction History (Sensitive Financial Data) \\ \hline
\end{tabular}
\end{table}

\section{Affected Security Attributes}
\label{label:SecurityAttributes}

The SQL injection affects Confidentiality since everyone can just leak data; Integrity, since anyone can change it; Availability, causing DOS if the data is deleted; undermining Accountability, since any mallicious party can perform actions as if they were a legitimiate actor. \\

All 1,2, and 4 affect non-repudiation since, for 1. Database records can be maipulated, for 2 and 4, a man-in-the-middle can get ahold of a user's access tokens and perform actions on their behalf.

\begin{table}[h!]
\centering
\caption{Security Attributes Affected by Vulnerabilities}
\label{tab:vulnerability_ciaan}
\begin{tabular}{|l|l|p{4cm}|p{4cm}|}
\hline
\textbf{Vuln. number} & \textbf{Name} & \textbf{primary assets} & \textbf{Affected CIAAN attributes} \\ \hline
1 & SQL injection & user database, \texttt{app.py} & Confidentiality, Integrity, Availability, Accountability, Non-repudiation \\ \hline
2 & Improper Certificate Validation & Network Traffic, External Data & Confidentiality, Integrity \\ \hline
3 & DOM-based XSS & User Browser, \texttt{forgot\_password.html} & Confidentiality, Integrity, Non-repudiation \\ \hline
4 & Missing 'Secure' Cookie Attribute & JWT Session Token & Confidentiality, Non-repudiation \\ \hline
\end{tabular}
\end{table}

\par \textbf{Vulnerability 5 (API Exposure)} affects \textbf{Confidentiality} because it reveals the internal logic and available methods of the application to unauthenticated actors, information that should be restricted to developers.
\par \textbf{Vulnerability 6 (SQL Injection)} severely impacts \textbf{Confidentiality} as it allows dumping the entire transaction table. It also threatens \textbf{Integrity} because, depending on database permissions, an attacker might escalate the injection to modify or delete transaction records.

\begin{table}[h!]
\centering
\caption{Security Attributes Affected by Offensive Vulnerabilities}
\label{tab:offensive_ciaan}
\begin{tabular}{|l|l|p{4cm}|p{4cm}|}
\hline
\textbf{No.} & \textbf{Name} & \textbf{Primary Assets} & \textbf{Affected CIAAN} \\ \hline
5 & API Documentation Exposure & API Blueprint / System Metadata & Confidentiality, Availability \\ \hline
6 & SQL Injection in API & Transaction Database & Confidentiality, Integrity, Accountability \\ \hline
\end{tabular}
\end{table}

\section{Tools Employed}
\label{label:Tools}

\par \textbf{Snyk Code} was employed as the primary Static Application Security Testing (SAST) tool to implement the defensive security strategy. This tool integrates directly into the development workflow to analyze the source code for security vulnerabilities without requiring code execution. For this investigation, we utilized Snyk's capability to parse the application's dependency tree and source files to identify known vulnerabilities (CVEs) and code quality issues, such as SQL injection risks and improper certificate validation. One significant benefit of using Snyk is its real-time scanning capability, which provided immediate feedback on security flaws as the code was being reviewed. A second key benefit is its actionable remediation advice, which not only identifies the line of code causing the issue but often provides context-aware fix suggestions, significantly reducing the time required for the remediation phase

Nessus, from Tenable was used to scan the hosted version of that website.

\par \textbf{Burp Suite Community Edition} was the core tool for the offensive approach. It is a comprehensive platform for web application security testing.
\begin{itemize}
    \item \textbf{Proxy Interceptor:} This allowed us to capture requests generated by the browser (or the API docs interface) and inspect the exact headers and JSON payloads being sent to the server.
    \item \textbf{Repeater:} This was crucial for the SQL Injection testing. It allowed us to resend the same request multiple times with slightly modified payloads (fuzzing) to observe how the server responds to SQL syntax errors vs. valid injections, without needing to use the browser UI.
\end{itemize}
\par \textbf{Benefit:} It provides granular control over the HTTP traffic, enabling the identification of vulnerabilities that are invisible in a standard browser view.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/api_burpsuite_http_history.png}
    \caption{Burp Suite HTTP History showing intercepted API traffic}
    \label{fig:burp_history}
\end{figure}

\subsubsection{Nessus}
This is what host discovery looks like in this tool.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/nessus/host-discovery-for-vulnbank.png}
    \caption{Nessus overview of vulnerabilities from dashboard.}
\end{figure}

And these are all the possible scan types.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/nessus/scan-types.png}
    \caption{All nessus scan types}
\end{figure}

I've performed 2 types of scans on the platform, a Basic Network Scan, and a Web Application Tests scan. The former found Chiphertext SWEET32 collision severe attacks, but my laptop can't handle all that data aquisition and requests, so I'm instead focusing on the ones found by the latter scan.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/nessus/scans-ive-made.png}
    \caption{Dashboard of scans}
\end{figure}

\section{Test Design. Test Execution. Test Report}
\label{label:Tests}

\subsection{Defensive Approach}

\par In the defensive approach, the "Test Execution" phase consisted of performing a Static Application Security Testing (SAST) scan using Snyk. The tool parsed the application source code to identify patterns matching known Common Weakness Enumerations (CWEs).

\par The table below summarizes the four vulnerabilities selected for investigation, detailing their severity, the specific application feature affected, and the security attributes (from the CIA triad) compromised.

\begin{table}[h!]
\centering
\begin{tabular}{|p{4cm}|l|p{4cm}|l|}
\hline
\textbf{Vulnerability Name} & \textbf{Severity} & \textbf{Affected Feature} & \textbf{Security Attribute} \\ \hline
SQL Injection (CWE-89) & High & API: Password Reset & Confidentiality, Integrity \\ \hline
Improper Certificate Validation (CWE-295) & High & API: Profile Upload  & Confidentiality \\ \hline
DOM-based XSS (CWE-79) & Medium & UI: Forgot Password  & Integrity \\ \hline
Insecure Cookie Attribute (CWE-614) & Low & Auth: Login Session & Confidentiality \\ \hline
\end{tabular}
\caption{Summary of Vulnerabilities Detected via SAST Scan}
\label{tab:vuln_summary}
\end{table}

\subsubsection{Test Report Evidence}
\par The following figures provide evidence of the test execution results generated by the Snyk tool. These reports detail the specific lines of code responsible for the vulnerabilities and the estimated impact.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/vul_01-sql-injection.png} % SQL Injection
    \caption{SQL Injection Detection}
    \label{fig:sqli_evidence}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/vul_02-certificate-validation.png} % Cert Validation
    \caption{Improper Certificate Validation}
    \label{fig:cert_evidence}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/vul_03-corss-site-scripting.png} % XSS
    \caption{DOM-based XSS Detection}
    \label{fig:xss_evidence}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/vul_04-sensitive-cookie.png} % Cookie
    \caption{Insecure Cookie Attribute}
    \label{fig:cookie_evidence}
\end{figure}

\begin{table} [H]
\centering
\begin{tabular}{l|l|l|l|l}
Feature & TC ID & Input1 & Input2 & Expected Output \\ \hline
F001  &TC01 & 42 & 15 & 100\\
F001  &TC02 & 1 & -2 & 3\\
F002  &TC03 & 111 & 90 & -74
\end{tabular}
\caption{\label{tab:TCs1}TCs table.}
\end{table}

Table \ref{tab:TCs1} shows the TCs designed to evaluate the vulnerability AAA over F001 and F002.

\subsection{Offensive Approach Test Design}
\par We utilized Equivalence Partitioning and Boundary Value Analysis to design our test cases, focusing on identifying valid vs. invalid inputs that could trigger unexpected server behavior.

\begin{table}[H]
\centering
\caption{Offensive Approach Test Cases}
\label{tab:offensive_tcs}
\begin{tabular}{|l|l|l|l|p{3cm}|}
\hline
\textbf{Feature} & \textbf{TC ID} & \textbf{Input} & \textbf{Expected Output} & \textbf{Actual Result} \\ \hline
API Docs & TC\_OFF\_01 & URL: \texttt{/api/docs} (No Auth) & 403 Forbidden / Login & 200 OK (Swagger UI) \\ \hline
API Docs & TC\_OFF\_02 & URL: \texttt{/api/v1/unknown} & 404 Not Found & 404 Not Found \\ \hline
Transact. API & TC\_OFF\_03 & Param: \texttt{id=1} (Valid) & JSON for User 1 & JSON for User 1 \\ \hline
Transact. API & TC\_OFF\_04 & Param: \texttt{id=1'} (Syntax) & 500 Server Error & 500 Server Error \\ \hline
Transact. API & TC\_OFF\_05 & Param: \texttt{id=1' OR '1'='1} & 403 Forbidden & 200 OK + All Data \\ \hline
\end{tabular}
\end{table}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/api_documentation.png}
    \caption{Exposed Swagger UI API Documentation at /api/docs}
    \label{fig:api_docs}
\end{figure}


\subsubsection{Identified by Nessus}
Nessus found: Web Server Transmits Cleartext Credentials.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/nessus/nessus-cleartext-creds.png}
    \caption{Nessus-found cleartext creds vuln.}
\end{figure}

As well as: Web Application Potentially Vulnerable to Clickjacking.


\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/nessus/clickjacking-nessus.png}
    \caption{Clickjacking vulnerability.}
\end{figure}



\section{Vulnerability Exploit}
\label{label:Exploit}

\subsection{Manual Exploit}
\label{label:ManualExploit}

\par For Vulnerability 06, we manually exploited the endpoint using Burp Suite Repeater:
\begin{enumerate}
    \item Intercepted a legitimate request to \texttt{/api/transactions}.
    \item Modified the parameter to inject the payload: \texttt{' OR '1'='1}.
    \item Sent the request and observed that the response contained transaction data for users other than the authenticated one (e.g., admin).
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Figures/api_burpsuite_repeater.png}
    \caption{Manual Exploitation of SQL Injection using Burp Suite Repeater. The response reveals transaction history for all users.}
    \label{fig:sqli_proof}
\end{figure}

\subsection{Automated Exploit (POC)}
\label{label:AutomatedExploit}

\par The following Python script automates the exploitation of the SQL Injection to dump transaction data:

\par To demonstrate the severity and reproducibility of the SQL Injection vulnerability, we developed a Python script. This script bypasses the browser interface and interacts directly with the vulnerable API endpoint. It sends a crafted GET request containing the SQL payload \texttt{' OR '1'='1} injected into the \texttt{user\_id} parameter. If the server is vulnerable, it returns a JSON response containing the transaction history of all users, which the script then parses and displays. This proves that an automated tool could easily scrape the entire database.

\begin{verbatim}
import requests

# Target Configuration
TARGET_URL = "http://vulnbank.org/api/transactions"
PAYLOAD = "' OR '1'='1"

def exploit_sqli():
    print(f"[*] Attempting SQL Injection on {TARGET_URL}...")
    params = {'user_id': PAYLOAD} 
    try:
        response = requests.get(TARGET_URL, params=params)
        if response.status_code == 200:
            data = response.json()
            print(f"[+] Exploit Successful! Retrieved {len(data)} items.")
    except Exception as e:
        print(f"[!] Error: {e}")
\end{verbatim}


\section{Remediation Steps}
\label{sec:Remediation}

\subsection{Defensive Approach Remediation}

\par Following the recommendations provided by the Snyk SAST tool, we implemented fixes for the four selected vulnerabilities. The goal was to neutralize the security risks by modifying the source code to adhere to secure coding standards.

\subsubsection{Remediation of Vulnerability 01: SQL Injection}
\par \textbf{Reasoning:} The Snyk report identified that the use of Python f-strings to construct SQL queries allowed user input to alter the query logic. To fix this, we adopted the \textit{Parameterized Query} pattern (Prepared Statements). This is the industry-standard solution because it forces the database engine to treat user input strictly as data, effectively neutralizing any injected SQL commands.

\par \textbf{Code Change (\texttt{app.py}):}
\begin{itemize}
    \item \textbf{Before (Vulnerable):}
    \begin{verbatim}
    # Vulnerable: Input is directly embedded in the query string
    user = execute_query(
        f"SELECT id FROM users WHERE username='{username}'"
    )
    \end{verbatim}
    
    \item \textbf{After (Fixed):}
    \begin{verbatim}
    # Fixed: Using parameterized query syntax
    query = "SELECT id FROM users WHERE username=?"
    user = execute_query(query, (username,))
    \end{verbatim}
\end{itemize}

\subsubsection{Remediation of Vulnerability 02: Improper Certificate Validation}
\par \textbf{Reasoning:} The application was explicitly configured to ignore SSL certificate errors (\texttt{verify=False}), exposing it to Man-in-the-Middle attacks. We remediated this by enforcing certificate validation. Although Snyk suggested simply removing the flag (since \texttt{True} is the default), we explicitly set it to \texttt{True} to make the security intent clear to future developers.

\par \textbf{Code Change (\texttt{app.py}):}
\begin{itemize}
    \item \textbf{Before (Vulnerable):}
    \begin{verbatim}
    resp = requests.get(image_url, timeout=10, 
                        allow_redirects=True, verify=False)
    \end{verbatim}
    
    \item \textbf{After (Fixed):}
    \begin{verbatim}
    resp = requests.get(image_url, timeout=10, 
                        allow_redirects=True, verify=True)
    \end{verbatim}
\end{itemize}

\subsubsection{Remediation of Vulnerability 03: Cross-site Scripting (XSS)}
\par \textbf{Reasoning:} The frontend code used the \texttt{innerHTML} property to display user-controlled messages. This allows the browser to render any HTML tags (including malicious \texttt{<script>} tags) contained in the message. We chose to replace this with the \texttt{textContent} property. This solution was selected because it is the most performant way to strip HTML context and render the output as pure text, fully preventing DOM-based XSS.

\par \textbf{Code Change (\texttt{templates/forgot\_password.html}):}
\begin{itemize}
    \item \textbf{Before (Vulnerable):}
    \begin{verbatim}
    document.getElementById('message').innerHTML = data.message;
    \end{verbatim}
    
    \item \textbf{After (Fixed):}
    \begin{verbatim}
    document.getElementById('message').textContent = data.message;
    \end{verbatim}
\end{itemize}

\subsubsection{Remediation of Vulnerability 04: Sensitive Cookie Without 'Secure' Attribute}
\par \textbf{Reasoning:} The session cookie was missing the \texttt{secure} flag, allowing it to be transmitted over unencrypted HTTP connections. We updated the cookie configuration to include \texttt{secure=True}. This ensures the browser will never send the cookie unless the connection is encrypted (HTTPS), protecting the session token from interception.

\par \textbf{Code Change (\texttt{app.py}):}
\begin{itemize}
    \item \textbf{Before (Vulnerable):}
    \begin{verbatim}
    response.set_cookie('token', token, httponly=True)
    \end{verbatim}
    
    \item \textbf{After (Fixed):}
    \begin{verbatim}
    response.set_cookie('token', token, httponly=True, secure=True)
    \end{verbatim}
\end{itemize}

\subsection{Verification (Re-Scan)}
\par After applying the remediation steps detailed above, we performed a secondary scan using Snyk to verify the removal of the vulnerabilities. The screenshots below illustrates the initial and updated report summary, confirming that the some issues have been resolved.


\begin{figure}[H]
\centering
\includegraphics[width=0.25\linewidth]{Figures/snyk-report-before-fix.png}
\caption{\label{fig:initial-report} Initial Snyk Scan Report Summary }
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.25\linewidth]{Figures/snyk-report-before-fix.png}
\caption{\label{fig:initial-report} Snyk Re-Scan Report Summary showing reduced vulnerability count }
\end{figure}


\subsection{Offensive Approach Remediation}

\subsubsection{Remediation of Vulnerability 05: API Documentation}
\par Access to API documentation should be restricted in production.
\par \textbf{Code Change (Python/Flask Example):}
\begin{verbatim}
if os.getenv('FLASK_ENV') == 'production':
    # Disable Swagger UI
    app.config['SWAGGER_UI_DOC_EXPANSION'] = 'none'
\end{verbatim}

\subsubsection{Remediation of Vulnerability 06: SQL Injection}
\par The root cause is the concatenation of user input. We must use Parameterized Queries.
\par \textbf{Code Change:}
\begin{itemize}
    \item \textbf{Before:} \texttt{cursor.execute(f"SELECT * FROM txns WHERE id = '{uid}'")}
    \item \textbf{After:} \texttt{cursor.execute("SELECT * FROM txns WHERE id = ?", (uid,))}
\end{itemize}




\section{Vulnerability Reporting}
\label{label:Reporting}

\subsection{Vulnerability Reporting (RIMSEC Strategy)}
\par We selected the RIMSEC strategy to report the SQL Injection vulnerability:
\begin{itemize}
    \item \textbf{Reproducibility:} The issue is 100\% reproducible using the payload \texttt{' OR '1'='1}.
    \item \textbf{Integrity:} The integrity is compromised as the injection could potentially be escalated to modify data.
    \item \textbf{Mitigation:} Requires replacing dynamic SQL with parameterized queries.
    \item \textbf{Severity:} \textbf{High}. It exposes sensitive financial data of all users.
    \item \textbf{Exploitability:} \textbf{Easy}. Requires only a browser or proxy, no authentication bypass tools needed.
    \item \textbf{Confidentiality:} Breached. Financial transaction logs are exposed.
\end{itemize}

\section{Conclusions}
\label{label:Conclusions}

\par Working on the QASST Project using the VulnBank application provided our team with valuable hands-on experience in bridging the gap between defensive and offensive security mindsets. One of the key lessons learned was the distinct difference in perspective: while the defensive approach (SAST with Snyk) provided rapid identification of bad coding patterns (like missing SSL verification), the offensive approach (DAST with Burp Suite) was crucial in validating which of those theoretical vulnerabilities were actually exploitable in a runtime environment.

\par The collaboration within the team was effective, allowing us to correlate findings. For instance, the "Missing Secure Cookie Attribute" found via static analysis was confirmed by the offensive team's ability to intercept traffic using Burp Suite. This reinforced the idea that security must be layered; relying solely on code review or solely on penetration testing is insufficient for a critical application like a banking system.

\par Regarding the tools, we found that while automated scanners like Nessus and Snyk are excellent for covering a wide breadth of issues quickly, they often lack the context that manual testing provides. The SQL Injection in the API, for example, required manual logic manipulation in Burp Suite to fully understand the data structure and impact, something a generic scanner might miss or misclassify. In conclusion, this project highlighted that securing a modern web application requires a continuous integration of both automated security gates and manual penetration testing.


\bibliographystyle{alpha}
\bibliography{sample}

\end{document}
